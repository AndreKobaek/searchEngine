\section{Ranking Algorithms}
When a search is done on our search-engine, the method \code{getMachingQueries} in \code{QueryHandler} finds all the websites that matches the query. But of course some of the matching websites are more relevant than others, for the given query. To show the user the most relevant pages at the top, we need a way to rank the websites according to relevance, i.e we need a ranking algorithm. There are many different ways to rank a website, we have chosen to implement the term-frequency algorithm (TF-algorithm), the term-frequency inverse-document-frequency (TFIDF-algorithm), and also our own  term-frequency inverse-corpus-frequency (TFICF-algorithm).    


\subsection{Term Frequency}
Keeping in line with the notation at \cite{wikiTFIDF} the term frequency, TF, is calculated as follows.

\[ TF = \frac{f_{t,d}}{\sum_{i \in d}f_{i,d}} \]

Note that we have choosen the term frequency that is weighted by the total number of words in the document/site. The corresponding Java implementation is shown in listing \ref{lst:tf}.

\begin{lstlisting}[language=Java,
					caption={Implementation of calculating TF rating.},
					label={lst:tf}]
/**
* JavaDoc
*
*/
for (Website site : sites {
for (String word : site.getWords()) {
// do something	
}
// do something more
}

\end{lstlisting}


\subsection{Term Frequency - Inverse Document Frequency}
\[ TFIDF = TF \cdot \log{\left(\frac{N}{|\{d \in D : t \in d \}|}\right)}  \]

\begin{lstlisting}[language=Java, caption=This is a code example.]
/**
* JavaDoc
*
*/
for (Website site : sites {
for (String word : site.getWords()) {
// do something	
}
// do something more
}
\end{lstlisting}


\subsection{Term Frequency - Inverse \emph{Corpus} Frequency}
Instead of using the inverse document frequency as above, it would also be sensible to use the \emph{inverse term frequency} with respect to the whole database/corpus. Lets call that algorithm for TFICF (Term frequency - Inverse Corpus Frequency). A Java implementation is shown in listing \ref{lst:TFICF}.
    
\[ TFICF = TF \cdot \log{\left( \frac{a}{b} \right) } \]


\begin{lstlisting}[language=Java, caption=This is a code example., label=lst:TFICF]
/**
* JavaDoc
*
*/
for (Website site : sites {
for (String word : site.getWords()) {
// do something	
}
// do something more
}
\end{lstlisting}




\subsection{Comparison of Algorithms}

Conceptual differences:


Differences in performance: haven't tested this yet.


\subsection{Design considerations}
In this section we will describe how we chose to embed/implement ranking algorithms in our search-engine. We actually have two different working implementations, and there was a passionate group discussion about which implementation to chose for our search-engine.  

A common rule of thumb for deciding on how to distribute responsibility between classes and methods in a program, is to say that methods correspond to verbs, and classes to nouns. This verb/noun method is described in \cite[p.530]{BK}.
But what kind of word is `rank` or `score`, a verb or a noun? Actually it can be both, and this suggests that we can implement a ranking algorithm using different design styles.

Both implementations have some amount of code duplication which could be partially mitigated by ....


\subsubsection{Option 1: Score as Utility class}
\begin{figure}[t]
	\centering
	%\includegraphics[width=\textwidth]{graphics/..}
	\caption{UML Diagram for the search-engine when Score is a utility class.}
	\label{fig:uml:score-as-utility}
\end{figure}

In the first implementation we tried, we wrote a utility class named \code{Score} which had static rank methods for ranking websites.   
A UML class diagram for this design is shown if figure \ref{fig:uml:utilityClass}, and snippets of relevant code lines from the implementation is shown in listing \ref{lst:utilityClass}. 
A drawback of this method is that it doesn't have a \code{Score} interface as specified in the mandatory requirements for the assignment.  

\begin{lstlisting}[language=Java, caption=This is a code example., label=lst:utilityClass]

//// From Score class 

	// do something	


//// From SearchEngine 

	// do something more

\end{lstlisting}


\subsubsection{Option 2: Score as Interface}
\begin{figure}[t]
	\centering
	%\includegraphics[width=\textwidth]{graphics/..}
	\caption{UML Diagram for search-engine when using an interface Score.}
	\label{fig:uml:score-as-interface}
\end{figure}

Another option which largely preserves the same division of responsibility is shown in the class diagram in figure \ref{fig:uml:score-as-interface}.    
This is the solution we went with in our final version of the code (version...). Relevant coding lines from the implementation is shown in listing \ref{lst:scoreInterface}.

\begin{lstlisting}[language=Java, caption=This is a code example., label=lst:scoreInterface]

//// From TFIDFScore class 

	// do something	


//// From SearchEngine 

// do something more

\end{lstlisting}



